return {
	[0] = {Mnemonic = "MOVE",   	Type = "iABC", 	PseudoCode = "R(A) := R(B)"},
	[1] = {Mnemonic = "LOADK",  	Type = "iABx", 	PseudoCode = "R(A) := Kst(Bx)"},
	[2] = {Mnemonic = "LOADBOOL", 	Type = "iABC", 	PseudoCode = "R(A) := (Bool)B; if (C) pc++"},
	[3] = {Mnemonic = "LOADNIL", 	Type = "iABC", 	PseudoCode = "R(A), R(A+1), ..., R(A+B-1) := nil"},
	[4] = {Mnemonic = "GETUPVAL", 	Type = "iABC", 	PseudoCode = "R(A) := UpValue[B]"}, 
	[5] = {Mnemonic = "GETGLOBAL", 	Type = "iABx", 	PseudoCode = "R(A) := Gbl[Kst(Bx)]"},
	[6] = {Mnemonic = "GETTABLE", 	Type = "iABC", 	PseudoCode = "R(A) := R(B)[RK(C)]"},
	[7] = {Mnemonic = "SETGLOBAL", 	Type = "iABx", 	PseudoCode = "Gbl[Kst(Bx)] := R(A)"},
	[8] = {Mnemonic = "SETUPVAL", 	Type = "iABC", 	PseudoCode = "UpValue[B] := R(A)"},
	[9] = {Mnemonic = "SETTABLE", 	Type = "iABC", 	PseudoCode = "R(A)[RK(B)] := RK(C)"},
	[10] = {Mnemonic = "NEWTABLE", 	Type = "iABC", 	PseudoCode = "R(A) := {}; size = B, C"},
	[11] = {Mnemonic = "SELF", 		Type = "iABC", 	PseudoCode = "R(A+1) := R(B); R(A) := R(B)[RK(C)]"},
	[12] = {Mnemonic = "ADD", 		Type = "iABC", 	PseudoCode = "R(A) := RK(B) + RK(C)"},
	[13] = {Mnemonic = "SUB", 		Type = "iABC", 	PseudoCode = "R(A) := RK(B) - RK(C)"},
	[14] = {Mnemonic = "MUL", 		Type = "iABC", 	PseudoCode = "R(A) := RK(B) * RK(C)"},
	[15] = {Mnemonic = "DIV", 		Type = "iABC", 	PseudoCode = "R(A) := RK(B) / RK(C)"},
	[16] = {Mnemonic = "MOD", 		Type = "iABC", 	PseudoCode = "R(A) := RK(B) % RK(C)"},
	[17] = {Mnemonic = "POW", 		Type = "iABC", 	PseudoCode = "R(A) := RK(B) ^ RK(C)"},
	[18] = {Mnemonic = "UNM", 		Type = "iABC", 	PseudoCode = "R(A) := -R(B)"},
	[19] = {Mnemonic = "NOT", 		Type = "iABC", 	PseudoCode = "R(A) := not R(B)"},
	[20] = {Mnemonic = "LEN", 		Type = "iABC", 	PseudoCode = "R(A) := length of R(B)"},
	[21] = {Mnemonic = "CONCAT", 	Type = "iABC", 	PseudoCode = "R(A) := R(B) .. ... .. R(C)"},
	[22] = {Mnemonic = "JMP", 		Type = "iAsBx", PseudoCode = "pc += sBx"},
	[23] = {Mnemonic = "EQ", 		Type = "iABC", 	PseudoCode = "if ((RK(B) == RK(C)) ~= A) then pc++"},
	[24] = {Mnemonic = "LT", 		Type = "iABC", 	PseudoCode = "if ((RK(B) < RK(C)) ~= A) then pc++"},
	[25] = {Mnemonic = "LE", 		Type = "iABC", 	PseudoCode = "if ((RK(B) <= RK(C)) ~= A) then pc++"},
	[26] = {Mnemonic = "TEST", 		Type = "iABC", 	PseudoCode = "if not (R(A) <=> C) then pc++"},
	[27] = {Mnemonic = "TESTSET", 	Type = "iABC", 	PseudoCode = "if (R(B) <=> C) then R(A) := R(B) else pc++"},
	[28] = {Mnemonic = "CALL", 		Type = "iABC", 	PseudoCode = "R(A), ..., R(A+C-2) := R(A)(R(A+1), ..., R(A+B-1))"},
	[29] = {Mnemonic = "TAILCALL", 	Type = "iABC", 	PseudoCode = "return R(A)(R(A+1), ..., R(A+B-1))"},
	[30] = {Mnemonic = "RETURN", 	Type = "iABC", 	PseudoCode = "return R(A), ..., R(A+B-2)"},
	[31] = {Mnemonic = "FORLOOP", 	Type = "iAsBx", PseudoCode = "R(A) += R(A+2); if R(A) <= R(A+1) then { pc += sBx; R(A+3) = R(A) }"},
	[32] = {Mnemonic = "FORPREP", 	Type = "iAsBx", PseudoCode = "R(A) -= R(A+2); pc += sBx"},
	[33] = {Mnemonic = "TFORLOOP", 	Type = "iABC", 	PseudoCode = "R(A+3), ..., R(A+2+C) := R(A)(R(A+1), R(A+2)); if R(A+3) ~= nil then R(A+2) = R(A+3) else pc++"},
	[34] = {Mnemonic = "SETLIST", 	Type = "iABC", 	PseudoCode = "R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B"},
	[35] = {Mnemonic = "CLOSE", 		Type = "iABC", 	PseudoCode = "close all variables in the stack up to (>=) R(A)"},
	[36] = {Mnemonic = "CLOSURE", 	Type = "iABx", 	PseudoCode = "R(A) := closure(KPROTO[Bx], R(A), ..., R(A+n))"},
	[37] = {Mnemonic = "VARARG", 	Type = "iABC", 	PseudoCode = "R(A), R(A+1), ..., R(A+B-1) := vararg"},
	[38] = {Mnemonic = "INVALID", 	Type = "", 		PseudoCode = "Invalid opcode or undefined behavior"}
}